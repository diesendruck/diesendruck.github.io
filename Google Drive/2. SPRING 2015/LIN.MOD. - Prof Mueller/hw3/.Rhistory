#   weight.sum: A vector or weight sums for the function of interest.
output <- 0
weight.sum <- 0
len <- length(pairs[,2])
hat.row <- c()
# Compute the prediction for x.star as a local linear regression (D=1)
# weighted sum of all y.i's.
for (i in 1:len) {
x.i <- pairs[i,1]
y.i <- pairs[i,2]
kernel.i <- WeightFunction(x.i, x.star, bandwidth)
# Define s2 and s1 to compute weights in D=1 local polynomial regression.
s2 <- 0
for (j in 1:len) {
x.j <- pairs[j,1]
kernel.j <- WeightFunction(x.j, x.star, bandwidth)
s2 <- s2 + kernel.j*(x.j-x.star)^2
}
s1 <- 0
for (k in 1:len) {
x.k <- pairs[k,1]
kernel.k <- WeightFunction(x.k, x.star, bandwidth)
s1 <- s1 + kernel.k*(x.k-x.star)
}
# Compute total local polynomial (D=1) weight for each y.i.
weight.i <- kernel.i*(s2-(x.i-x.star)*s1)
weight.sum <- weight.sum + weight.i
hat.row <- c(hat.row, weight.i)
output.i <- weight.i*y.i
output <- output + output.i
}
# Normalize weights by dividing by weight sum.
output <- output/weight.sum
hat.row <- hat.row/weight.sum
l <- list(output, hat.row, weight.sum)
return (l)
}
WeightFunction <- function(x.i, x.star, bandwidth) {
# Gives weight of the y.i that is associated with x.i, according to a
# Gaussian kernel.
#
# Args:
#   x.i: Nearby X value to x.star, used to determine a weight for its Y.
#   x.star: The center of the smoother function.
#   bandwidth: A neighborhood around the requested x.star, used to average
#     the area under the smoother function.
#
# Returns:
#   weight: The weight of the y that corresponds to x.i.
density <- ((2*pi)^(-1/2))*exp(-1/2*((x.i-x.star)/bandwidth)^2)
weight <- density/bandwidth
return (weight)
}
PerformLOOCV <- function(fitted.curves) {
# Compares the predictions using LOOCV.
#
# Args:
#   fitted.curves: List of X-values, three sets of predicted Y's based on
#     different bandwidths, the pairs matrix, and list of hat matrices.
#
# Returns:
#   loocv.scores: Vector of LOOCV scores for each of three functions.
x.values <- fitted.curves[[1]]
y.predictions <- list(fitted.curves[[2]],
fitted.curves[[3]],
fitted.curves[[4]])
pairs <- fitted.curves[[5]]
pairs <- pairs[order(pairs[,1]),]
hats <- fitted.curves[[6]]
num.xvalues <- length(x.values)
num.ypredictions <- length(y.predictions)
loocv.scores <- c()
# Compute re-weighted sum of squared errors for all y prediction functions.
for (i in 1:num.ypredictions) {
pred.func.i <- y.predictions[[i]]
sum.rw.sq.err.i <- 0
hat.i <- t(hats[[i]])
# For given function, compute re-weighted squared errors, and add to sum.
for (j in 1:num.xvalues) {
predicted.value <- pred.func.i[j]
true.value <- pairs[j,2]
rw.sq.err <- ((predicted.value - true.value)/(1-hat.i[j,j]))^2
sum.rw.sq.err.i <- sum.rw.sq.err.i + rw.sq.err
}
loocv.element <- sum.rw.sq.err.i
loocv.scores <- c(loocv.scores, loocv.element)
}
return (loocv.scores)
}
CalculateResiduals <- function(fitted.curves) {
# Calculates and plots residuals for first of three fitted curves.
#
# Args:
#   fitted.curves: List of X-values, three sets of predicted Y's based on
#     different bandwidths, the pairs matrix, and list of hat matrices.
#
# Returns:
#   NA: None.
x.values <- fitted.curves[[1]]
y.prediction <- fitted.curves[[2]]
pairs <- fitted.curves[[5]]
pairs <- pairs[order(pairs[,1]),]
hats <- fitted.curves[[6]]
hat1 <- t(hats[[1]])
weighted.sums1 <- fitted.curves[[7]]
num.xvalues <- length(x.values)
# Compute residuals for y prediction.
residuals <- c()
for (j in 1:num.xvalues) {
predicted.value <- y.prediction[j]
true.value <- pairs[j,2]
sq.err <- (predicted.value - true.value)^2
residuals <- c(residuals, sq.err)
}
plot(x.values, residuals, xlab="Temp", ylab="Sq.Res. on Avg. Daily Bill",
main="Residuals for Bandwidth=0.1")
# Estimate each var(f(x.i)) = sum(weight.i) * (variance estimate).
var.estimate <- sum(residuals)/(117-1)
se.estimate <- sqrt(var.estimate)
vars.fxi <- c()
for (k in 1:num.xvalues) {
vars.fxi <- c(vars.fxi, (sum(hat1[k,])^2)*var.estimate)
}
se.fxi <- sqrt(vars.fxi)
# Plot prediction with 95% confidence interval lines.
plot(pairs[,1], pairs[,2], col="gray", xlab="Temp", ylab="Avg Daily Bill",
main="Curve Fitting with Local Linear Regression")
lines(x.values, y.prediction, col="grey20", lwd="2")
lines(x.values, y.prediction+1.96*se.fxi, col="dodgerblue3", lwd="2", lty=3)
lines(x.values, y.prediction-1.96*se.fxi, col="steelblue1", lwd="2", lty=3)
return (NA)
}
Main()
# Stat Mod 2 - Local Linear Estimator (p.6)
#
# Fits the local linear estimator using a Gaussian kernel for a specified
# choice of bandwidth h. (Chooses a bandwidth using LOOCV.)
#
# Author: Maurice Diesendruck
# Last updated: 2015-02-24
Main <- function() {
# Performs local linear regression, choosing a bandwidth with LOOCV.
#
# Args:
#   NA
#
# Returns:
#   NA
fitted.curves <- FitCurves(c(0.1, 1, 4), GetData)
loocv.scores <- PerformLOOCV(fitted.curves)
CalculateResiduals(fitted.curves)
}
GetData <- function() {
# Gets utilities.csv data.
#
# Args:
#   NA: None.
#
# Returns:
#   data: The csv file with given data.
setwd("~/Google Drive/2. SPRING 2015/STAT MOD 2 - Prof Scott/local polynomial regression")
contents <- read.csv("utilities.csv", header=T, sep=",")
data <- contents
# Add column for average daily gas bill, by dividing monthly gas bill by
# number of billing days.
data$avg.daily.bill <- data$gasbill/data$billingdays
plot(data$temp, data$avg.daily.bill)
return (data)
}
FitCurves <- function(bandwidths, GetData) {
# Wraps curve fitting steps into one, and allows choice of three bandwidths.
#
# Args:
#   bandwidths: Vector of three bandwidths.
#
# Returns:
#   fitted.curves: List of X-values, three sets of predicted Y's based on
#     different bandwidths, the pairs matrix, list of hat matrices, and
#     weight sums for the first prediction set.
data <- GetData()
pairs <- data[,c("temp", "avg.daily.bill")]
par(bty="l",las=1)
plot(pairs[,1], pairs[,2], col="gray", xlab="Temp", ylab="Avg Daily Bill",
main="Curve Fitting with Local Linear Regression")
# Predict output on test set "x" and plot. (Here, "x" is a uniformly
# distributed set of inputs on the range of the training set, designed to
# show the full density of the estimation.)
x <- seq(min(pairs[,1]), max(pairs[,1]), 1)
# Psych! Use exactly the same x's from data, to make LOOCV easier.
x <- sort(pairs[,1])
output1 <- PredictOutput(pairs, x, bandwidths[1])
output2 <- PredictOutput(pairs, x, bandwidths[2])
output3 <- PredictOutput(pairs, x, bandwidths[3])
lines(x, output1[[1]], col="steelblue1", lwd="2")
lines(x, output2[[1]], col="dodgerblue3", lwd="2")
lines(x, output3[[1]], col="grey20", lwd="2")
legend("topright", title="Bandwidth", legend=bandwidths, bty="n",
lty=c(1,1),lwd=c(3,3), col=c("steelblue1","dodgerblue3","grey20"))
hat1 <- matrix(output1[[2]], 117, 117)
hat2 <- matrix(output2[[2]], 117, 117)
hat3 <- matrix(output3[[2]], 117, 117)
hats <- list(hat1, hat2, hat3)
weight.sums1 <- output1[[3]]
fitted.curves <- list(x, output1[[1]], output2[[1]], output3[[1]], pairs,
hats, weight.sums1)
return (fitted.curves)
}
PredictOutput <- function(pairs, x.star, bandwidth) {
# Predicts probability density for given x.star, based on pairs of data and
# a weight function. Specifically, doing sum(weight.i*y.i), where each weight
# comes from WeightFunction.
#
# Args:
#   pairs: The pairs of X's and corresponding Y's, i.e. the data.
#   x.star: This is the point of interest, whose probability under the
#     density you want to find.
#   bandwidth: A neighborhood around the requested x.star, used to average
#     the area under the smoother function.
#
# Returns:
#   pred: The predicted value for the function of interest, at x.star.
#   hat.row: The row of the "hat" matrix, associated with that x.i.
#   weight.sum: A vector or weight sums for the function of interest.
output <- 0
weight.sum <- 0
len <- length(pairs[,2])
hat.row <- c()
# Compute the prediction for x.star as a local linear regression (D=1)
# weighted sum of all y.i's.
for (i in 1:len) {
x.i <- pairs[i,1]
y.i <- pairs[i,2]
kernel.i <- WeightFunction(x.i, x.star, bandwidth)
# Define s2 and s1 to compute weights in D=1 local polynomial regression.
s2 <- 0
for (j in 1:len) {
x.j <- pairs[j,1]
kernel.j <- WeightFunction(x.j, x.star, bandwidth)
s2 <- s2 + kernel.j*(x.j-x.star)^2
}
s1 <- 0
for (k in 1:len) {
x.k <- pairs[k,1]
kernel.k <- WeightFunction(x.k, x.star, bandwidth)
s1 <- s1 + kernel.k*(x.k-x.star)
}
# Compute total local polynomial (D=1) weight for each y.i.
weight.i <- kernel.i*(s2-(x.i-x.star)*s1)
weight.sum <- weight.sum + weight.i
hat.row <- c(hat.row, weight.i)
output.i <- weight.i*y.i
output <- output + output.i
}
# Normalize weights by dividing by weight sum.
output <- output/weight.sum
hat.row <- hat.row/weight.sum
l <- list(output, hat.row, weight.sum)
return (l)
}
WeightFunction <- function(x.i, x.star, bandwidth) {
# Gives weight of the y.i that is associated with x.i, according to a
# Gaussian kernel.
#
# Args:
#   x.i: Nearby X value to x.star, used to determine a weight for its Y.
#   x.star: The center of the smoother function.
#   bandwidth: A neighborhood around the requested x.star, used to average
#     the area under the smoother function.
#
# Returns:
#   weight: The weight of the y that corresponds to x.i.
density <- ((2*pi)^(-1/2))*exp(-1/2*((x.i-x.star)/bandwidth)^2)
weight <- density/bandwidth
return (weight)
}
PerformLOOCV <- function(fitted.curves) {
# Compares the predictions using LOOCV.
#
# Args:
#   fitted.curves: List of X-values, three sets of predicted Y's based on
#     different bandwidths, the pairs matrix, and list of hat matrices.
#
# Returns:
#   loocv.scores: Vector of LOOCV scores for each of three functions.
x.values <- fitted.curves[[1]]
y.predictions <- list(fitted.curves[[2]],
fitted.curves[[3]],
fitted.curves[[4]])
pairs <- fitted.curves[[5]]
pairs <- pairs[order(pairs[,1]),]
hats <- fitted.curves[[6]]
num.xvalues <- length(x.values)
num.ypredictions <- length(y.predictions)
loocv.scores <- c()
# Compute re-weighted sum of squared errors for all y prediction functions.
for (i in 1:num.ypredictions) {
pred.func.i <- y.predictions[[i]]
sum.rw.sq.err.i <- 0
hat.i <- t(hats[[i]])
# For given function, compute re-weighted squared errors, and add to sum.
for (j in 1:num.xvalues) {
predicted.value <- pred.func.i[j]
true.value <- pairs[j,2]
rw.sq.err <- ((predicted.value - true.value)/(1-hat.i[j,j]))^2
sum.rw.sq.err.i <- sum.rw.sq.err.i + rw.sq.err
}
loocv.element <- sum.rw.sq.err.i
loocv.scores <- c(loocv.scores, loocv.element)
}
return (loocv.scores)
}
CalculateResiduals <- function(fitted.curves) {
# Calculates and plots residuals for first of three fitted curves.
#
# Args:
#   fitted.curves: List of X-values, three sets of predicted Y's based on
#     different bandwidths, the pairs matrix, and list of hat matrices.
#
# Returns:
#   NA: None.
x.values <- fitted.curves[[1]]
y.prediction <- fitted.curves[[2]]
pairs <- fitted.curves[[5]]
pairs <- pairs[order(pairs[,1]),]
hats <- fitted.curves[[6]]
hat1 <- t(hats[[1]])
weighted.sums1 <- fitted.curves[[7]]
num.xvalues <- length(x.values)
# Compute residuals for y prediction.
residuals <- c()
for (j in 1:num.xvalues) {
predicted.value <- y.prediction[j]
true.value <- pairs[j,2]
sq.err <- (predicted.value - true.value)^2
residuals <- c(residuals, sq.err)
}
plot(x.values, residuals, xlab="Temp", ylab="Sq.Res. on Avg. Daily Bill",
main="Residuals for Bandwidth=0.1")
# Estimate each var(f(x.i)) = sum(weight.i) * (variance estimate).
var.estimate <- sum(residuals)/(117-1)
se.estimate <- sqrt(var.estimate)
vars.fxi <- c()
for (k in 1:num.xvalues) {
vars.fxi <- c(vars.fxi, (sum(hat1[k,])^2)*var.estimate)
}
se.fxi <- sqrt(vars.fxi)
# Plot prediction with 95% confidence interval lines.
plot(pairs[,1], pairs[,2], col="gray", xlab="Temp", ylab="Avg Daily Bill",
main="Curve Fitting with Local Linear Regression")
lines(x.values, y.prediction, col="grey20", lwd="2")
lines(x.values, y.prediction+1.96*se.fxi, col="dodgerblue3", lwd="2", lty=3)
lines(x.values, y.prediction-1.96*se.fxi, col="steelblue1", lwd="2", lty=3)
return (NA)
}
fitted.curves <- FitCurves(c(0.1, 1, 4), GetData)
x.values <- fitted.curves[[1]]
y.prediction <- fitted.curves[[2]]
pairs <- fitted.curves[[5]]
pairs <- pairs[order(pairs[,1]),]
hats <- fitted.curves[[6]]
hat1 <- t(hats[[1]])
weighted.sums1 <- fitted.curves[[7]]
num.xvalues <- length(x.values)
# Compute residuals for y prediction.
residuals <- c()
for (j in 1:num.xvalues) {
predicted.value <- y.prediction[j]
true.value <- pairs[j,2]
sq.err <- (predicted.value - true.value)^2
residuals <- c(residuals, sq.err)
}
plot(x.values, residuals, xlab="Temp", ylab="Sq.Res. on Avg. Daily Bill",
main="Residuals for Bandwidth=0.1")
# Estimate each var(f(x.i)) = sum(weight.i) * (variance estimate).
var.estimate <- sum(residuals)/(117-1)
se.estimate <- sqrt(var.estimate)
vars.fxi <- c()
for (k in 1:num.xvalues) {
vars.fxi <- c(vars.fxi, (sum(hat1[k,])^2)*var.estimate)
}
se.fxi <- sqrt(vars.fxi)
vars.fxi
vars.fxi <- c()
vars.fxi
k
vars.fxi <- c()
for (k in 1:num.xvalues) {
vars.fxi <- c(vars.fxi, sum((hat1[k,]^2))*var.estimate)
}
vars.fxi
se.fxi <- sqrt(vars.fxi)
se.fxi
help(qt)
t.scores <- qt(c(0.025, 0.975), 116)
t.scores
se.fxi <- sqrt(vars.fxi)
# Plot prediction with 95% confidence interval lines.
plot(pairs[,1], pairs[,2], col="gray", xlab="Temp", ylab="Avg Daily Bill",
main="Curve Fitting with Local Linear Regression")
t <- qt(c(0.025, 0.975), 116)
lines(x.values, y.prediction, col="grey20", lwd="2")
lines(x.values, y.prediction+t[1]*se.fxi, col="dodgerblue3", lwd="2", lty=3)
lines(x.values, y.prediction+t[1]*se.fxi, col="steelblue1", lwd="2", lty=3)
t <- qt(c(0.025, 0.975), 116)
lines(x.values, y.prediction, col="grey20", lwd="2")
lines(x.values, y.prediction+t[1]*se.fxi, col="dodgerblue3", lwd="2", lty=3)
lines(x.values, y.prediction+t[2]*se.fxi, col="steelblue1", lwd="2", lty=3)
plot(pairs[,1], pairs[,2], col="gray", xlab="Temp", ylab="Avg Daily Bill",
main="Curve Fitting with Local Linear Regression")
t <- qt(c(0.025, 0.975), 116)
lines(x.values, y.prediction, col="grey20", lwd="2")
lines(x.values, y.prediction+t[1]*se.fxi, col="dodgerblue3", lwd="2", lty=3)
lines(x.values, y.prediction+t[2]*se.fxi, col="steelblue1", lwd="2", lty=3)
plot(pairs[,1], pairs[,2], col="gray", xlab="Temp", ylab="Avg Daily Bill",
main="Curve Fitting with Local Linear Regression")
t <- qt(c(0.025, 0.975), 116)
lines(x.values, y.prediction, col="grey20", lwd="2")
lines(x.values, y.prediction+t[1]*se.fxi, col="dodgerblue3", lwd="2", lty=3)
lines(x.values, y.prediction+t[2]*se.fxi, col="steelblue1", lwd="2", lty=3)
source('~/Google Drive/2. SPRING 2015/STAT MOD 2 - Prof Scott/local polynomial regression/local linear estimator - F.R')
plot(pairs[,1], pairs[,2], col="gray", xlab="Temp", ylab="Avg Daily Bill",
main="Local Linear Regression with 95% CI")
t <- qt(c(0.025, 0.975), 116)
lines(x.values, y.prediction, col="grey20", lwd="2")
lines(x.values, y.prediction+t[1]*se.fxi, col="dodgerblue3", lwd="2", lty=3)
lines(x.values, y.prediction+t[2]*se.fxi, col="steelblue1", lwd="2", lty=3)
fitted.curves <- FitCurves(c(0.1, 1, 4), GetData)
loocv.scores <- PerformLOOCV(fitted.curves)
CalculateResiduals(fitted.curves)
fitted.curves <- FitCurves(c(0.1, 1, 6), GetData)
loocv.scores <- PerformLOOCV(fitted.curves)
loocv.scores
# Linear Models - Prof Mueller - HW3
library(Matrix)
RunModel <- function(data) {
# Gets file and data, and runs linear model.
#
# Args:
#   data: The data frame used for analysis.
#
# Returns:
#   model: A linear model fit object.
setwd("~/Google Drive/2. SPRING 2015/LIN.MOD. - Prof Mueller/hw3")
file.contents <- read.table("hw3data.txt", header=T)
data <- file.contents
attach(data)
model <- lm(deltaT ~ factor(proxy)*poly(latitude, 2), data=data, weights=1/sdev^2)
model <- lm(deltaT ~ -1+factor(proxy)*poly(latitude, 2), data=data, weights=1/sdev^2)
X = model.matrix(deltaT ~ factor(proxy)*poly(latitude, 2), data=data)
X1 = model.matrix(deltaT ~ factor(proxy)*poly(latitude, 2), data=data)
boxplot(deltaT ~ proxy)
return (model)
}
PrepData <- function() {
# Gets file and data, and prepares extra columns needed for analysis.
#
# Args:
#   NA: None.
#
# Returns:
#   data: A data frame ready for analysis.
setwd("~/Google Drive/2. SPRING 2015/LIN.MOD. - Prof Mueller/hw3")
file.contents <- read.table("hw3data.txt", header=T)
data <- file.contents
attach(data)
# Add different intercept for each proxy requires a dummy variable per proxy.
data$p1 <- ifelse(proxy==1, 1, 0)
data$p2 <- ifelse(proxy==2, 1, 0)
data$p3 <- ifelse(proxy==3, 1, 0)
data$p4 <- ifelse(proxy==4, 1, 0)
data$p5 <- ifelse(proxy==5, 1, 0)
data$p6 <- ifelse(proxy==6, 1, 0)
data$p7 <- ifelse(proxy==7, 1, 0)
data$p8 <- ifelse(proxy==8, 1, 0)
# Add latitude squared.
data$latsq <- latitude*latitude
# Add weight, where unnormalized weight = 1/var, and then normalize.
data$var <- sdev*sdev
data$inv.var <- 1/(data$var)
sum.of.inv.vars <- sum(data$inv.var)
data$weight <- data$inv.var/sum.of.inv.vars
return (data)
}
data <- PrepData()
model <- RunModel(data)
setwd("~/Google Drive/2. SPRING 2015/LIN.MOD. - Prof Mueller/hw3")
file.contents <- read.table("hw3data.txt", header=T)
data <- file.contents
attach(data)
model <- lm(deltaT ~ factor(proxy)*poly(latitude, 2), data=data, weights=1/sdev^2)
data
m2 <- lm(deltaT ~ factor(proxy)*poly(latitude, 2)+factor(T.M), data=data, weights=1/sdev^2)
summary(m2)
data
m2 <- lm(deltaT ~ factor(proxy)*poly(latitude, 2)+
factor(data[,4]), data=data, weights=1/sdev^2)
summary(m2)
m2 <- lm(deltaT ~ factor(proxy)*poly(latitude, 2)+
data[,4], data=data, weights=1/sdev^2)
m2 <- lm(deltaT ~ factor(proxy)*poly(latitude, 2)+
data[,4], data=data, weights=1/sdev^2)
summary(m2)
data
m2 <- lm(deltaT ~ poly(latitude, 2)+
data[,4], data=data, weights=1/sdev^2)
summary(m2)
m2 <- lm(deltaT ~ T.M*poly(latitude, 2), data=data, weights=1/sdev^2)
summary(m2)
data
model <- lm(deltaT ~ factor(9-proxy)*poly(latitude, 2), data=data, weights=1/sdev^2)
summary(model)
model <- lm(deltaT ~ factor(proxy)*poly(latitude, 2), data=data, weights=1/sdev^2)
